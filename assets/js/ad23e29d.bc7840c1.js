(window.webpackJsonp=window.webpackJsonp||[]).push([[754],{1176:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return y}));var r=n(0),a=n.n(r);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=a.a.createContext({}),c=function(e){var t=a.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return a.a.createElement(l.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},m=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,l=p(e,["components","mdxType","originalType","parentName"]),u=c(n),m=r,y=u["".concat(o,".").concat(m)]||u[m]||b[m]||i;return n?a.a.createElement(y,s(s({ref:t},l),{},{components:n})):a.a.createElement(y,s({ref:t},l))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},878:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return p})),n.d(t,"default",(function(){return c}));var r=n(3),a=n(8),i=(n(0),n(1176)),o={title:"Creating an ES2015 Map from an Array in TypeScript",author:"John Reilly",author_url:"https://github.com/johnnyreilly",author_image_url:"https://blog.johnnyreilly.com/img/profile.jpg",tags:["TypeScript","ES6","Array","ES2015","Map"],hide_table_of_contents:!1},s={permalink:"/2016/06/02/create-es2015-map-from-array-in-typescript",editUrl:"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/blog/2016-06-02-create-es2015-map-from-array-in-typescript.md",source:"@site/blog/2016-06-02-create-es2015-map-from-array-in-typescript.md",description:"I'm a great lover of ES2015's Map. However, just recently I tumbled over something I find a touch inconvenient about how you initialise a new Map from the contents of an Array in TypeScript.",date:"2016-06-02T00:00:00.000Z",formattedDate:"June 2, 2016",tags:[{label:"TypeScript",permalink:"/tags/type-script"},{label:"ES6",permalink:"/tags/es-6"},{label:"Array",permalink:"/tags/array"},{label:"ES2015",permalink:"/tags/es-2015"},{label:"Map",permalink:"/tags/map"}],title:"Creating an ES2015 Map from an Array in TypeScript",readingTime:2.095,truncated:!1,prevItem:{title:"Understanding Webpack's DefinePlugin (and using with TypeScript)",permalink:"/2016/07/23/using-webpacks-defineplugin-with-typescript"},nextItem:{title:"The Mysterious Case of Webpack, Angular and jQuery",permalink:"/2016/05/24/the-mysterious-case-of-webpack-angular-and-jquery"}},p=[{value:"This Doesn&#39;t Work",id:"this-doesnt-work",children:[]},{value:"This Does",id:"this-does",children:[]}],l={toc:p};function c(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"I'm a great lover of ES2015's ",Object(i.b)("inlineCode",{parentName:"p"},'<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a>'),". However, just recently I tumbled over something I find a touch inconvenient about how you initialise a new ",Object(i.b)("inlineCode",{parentName:"p"},"Map")," from the contents of an ",Object(i.b)("inlineCode",{parentName:"p"},"Array")," in TypeScript."),Object(i.b)("h2",{id:"this-doesnt-work"},"This Doesn't Work"),Object(i.b)("p",null,"We're going try to something like this: (pilfered from the MDN docs)"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},'var kvArray = [["key1", "value1"], ["key2", "value2"]];\n\n// Use the regular Map constructor to transform a 2D key-value Array into a map\nvar myMap = new Map(kvArray);\n')),Object(i.b)("p",null,"Simple enough right? Well I'd rather assumed that I should be able to do something like this in TypeScript:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},'const iAmAnArray [\n  { value: "value1", text: "hello" }\n  { value: "value2", text: "map" }\n];\n\nconst iAmAMap = new Map<string, string>(\n  iAmAnArray.map(x => [x.value, x.text])\n);\n')),Object(i.b)("p",null,"However, to my surprise this errored out with:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"[ts] Argument of type 'string[][]' is not assignable to parameter of type 'Iterable<[string, string]>'.\n  Types of property '[Symbol.iterator]' are incompatible.\n    Type '() => IterableIterator<string[]>' is not assignable to type '() => Iterator<[string, string]>'.\n      Type 'IterableIterator<string[]>' is not assignable to type 'Iterator<[string, string]>'.\n        Types of property 'next' are incompatible.\n          Type '(value?: any) => IteratorResult<string[]>' is not assignable to type '(value?: any) => IteratorResult<[string, string]>'.\n            Type 'IteratorResult<string[]>' is not assignable to type 'IteratorResult<[string, string]>'.\n              Type 'string[]' is not assignable to type '[string, string]'.\n                Property '0' is missing in type 'string[]'.\n")),Object(i.b)("p",null,"Disappointing right? It's expecting ",Object(i.b)("inlineCode",{parentName:"p"},"Iterable&lt;[string, string]&gt;")," and an ",Object(i.b)("inlineCode",{parentName:"p"},"Array")," with 2 elements that are strings is ",Object(i.b)("em",{parentName:"p"},"not")," inferred to be that."),Object(i.b)("h2",{id:"this-does"},"This Does"),Object(i.b)("p",null,"It emerges that there is a way to do this though; you just need to give the compiler a clue. You need to include a type assertion of ",Object(i.b)("inlineCode",{parentName:"p"}," as [string, string]")," which tells the compiler that what you've just declared is a ",Object(i.b)("inlineCode",{parentName:"p"},"Tuple")," of ",Object(i.b)("inlineCode",{parentName:"p"},"string")," and ",Object(i.b)("inlineCode",{parentName:"p"},"string"),". (Please note that ",Object(i.b)("inlineCode",{parentName:"p"},"[string, string]")," corresponds to the types of the ",Object(i.b)("inlineCode",{parentName:"p"},"Key")," and ",Object(i.b)("inlineCode",{parentName:"p"},"Value")," of your ",Object(i.b)("inlineCode",{parentName:"p"},"Map")," and should be set accordingly.)"),Object(i.b)("p",null,"So a working version of the code looks like this:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},'const iAmAnArray [\n  { value: "value1", text: "hello" }\n  { value: "value2", text: "map" }\n];\n\nconst iAmAMap = new Map<string, string>(\n  iAmAnArray.map(x => [x.value, x.text] as [string, string])\n);\n')),Object(i.b)("p",null,"Or, to be terser, this:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},'const iAmAnArray [\n  { value: "value1", text: "hello" }\n  { value: "value2", text: "map" }\n];\n\nconst iAmAMap = new Map( // Look Ma!  No type annotations\n  iAmAnArray.map(x => [x.value, x.text] as [string, string])\n);\n')),Object(i.b)("p",null,"I've raised this as an issue with the TypeScript team; you can find details ",Object(i.b)("a",{parentName:"p",href:"https://github.com/Microsoft/TypeScript/issues/8936"},"here"),"."))}c.isMDXComponent=!0}}]);