(window.webpackJsonp=window.webpackJsonp||[]).push([[620],{683:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return l})),n.d(t,"toc",(function(){return s})),n.d(t,"default",(function(){return c}));var r=n(3),a=n(7),o=(n(0),n(965)),i={title:"Creating an ES2015 Map from an Array in TypeScript",author:"John Reilly",author_url:"https://github.com/johnnyreilly",author_image_url:"https://avatars.githubusercontent.com/u/1010525?s=400&u=294033082cfecf8ad1645b4290e362583b33094a&v=4",tags:["TypeScript","ES6","Array","ES2015","Map"],hide_table_of_contents:!1},l={permalink:"/blog.johnnyreilly.com/2016/06/02/create-es2015-map-from-array-in-typescript",editUrl:"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/blog/2016-06-02-create-es2015-map-from-array-in-typescript.md",source:"@site/blog/2016-06-02-create-es2015-map-from-array-in-typescript.md",description:"I'm a great lover of ES2015's Map. However, just recently I tumbled over something I find a touch inconvenient about how you initialise a new Map from the contents of an Array in TypeScript.",date:"2016-06-02T00:00:00.000Z",tags:[{label:"TypeScript",permalink:"/blog.johnnyreilly.com/tags/type-script"},{label:"ES6",permalink:"/blog.johnnyreilly.com/tags/es-6"},{label:"Array",permalink:"/blog.johnnyreilly.com/tags/array"},{label:"ES2015",permalink:"/blog.johnnyreilly.com/tags/es-2015"},{label:"Map",permalink:"/blog.johnnyreilly.com/tags/map"}],title:"Creating an ES2015 Map from an Array in TypeScript",readingTime:2.095,truncated:!1,prevItem:{title:"Understanding Webpack's DefinePlugin (and using with TypeScript)",permalink:"/blog.johnnyreilly.com/2016/07/23/using-webpacks-defineplugin-with-typescript"},nextItem:{title:"The Mysterious Case of Webpack, Angular and jQuery",permalink:"/blog.johnnyreilly.com/2016/05/24/the-mysterious-case-of-webpack-angular-and-jquery"}},s=[{value:"This Doesn&#39;t Work",id:"this-doesnt-work",children:[]},{value:"This Does",id:"this-does",children:[]}],p={toc:s};function c(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"I'm a great lover of ES2015's ",Object(o.b)("inlineCode",{parentName:"p"},'<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a>'),". However, just recently I tumbled over something I find a touch inconvenient about how you initialise a new ",Object(o.b)("inlineCode",{parentName:"p"},"Map")," from the contents of an ",Object(o.b)("inlineCode",{parentName:"p"},"Array")," in TypeScript."),Object(o.b)("h2",{id:"this-doesnt-work"},"This Doesn't Work"),Object(o.b)("p",null,"We're going try to something like this: (pilfered from the MDN docs)"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-ts"},'var kvArray = [["key1", "value1"], ["key2", "value2"]];\n\n// Use the regular Map constructor to transform a 2D key-value Array into a map\nvar myMap = new Map(kvArray);\n')),Object(o.b)("p",null,"Simple enough right? Well I'd rather assumed that I should be able to do something like this in TypeScript:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-ts"},'const iAmAnArray [\n  { value: "value1", text: "hello" }\n  { value: "value2", text: "map" }\n];\n\nconst iAmAMap = new Map<string, string>(\n  iAmAnArray.map(x => [x.value, x.text])\n);\n')),Object(o.b)("p",null,"However, to my surprise this errored out with:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre"},"[ts] Argument of type 'string[][]' is not assignable to parameter of type 'Iterable<[string, string]>'.\n  Types of property '[Symbol.iterator]' are incompatible.\n    Type '() => IterableIterator<string[]>' is not assignable to type '() => Iterator<[string, string]>'.\n      Type 'IterableIterator<string[]>' is not assignable to type 'Iterator<[string, string]>'.\n        Types of property 'next' are incompatible.\n          Type '(value?: any) => IteratorResult<string[]>' is not assignable to type '(value?: any) => IteratorResult<[string, string]>'.\n            Type 'IteratorResult<string[]>' is not assignable to type 'IteratorResult<[string, string]>'.\n              Type 'string[]' is not assignable to type '[string, string]'.\n                Property '0' is missing in type 'string[]'.\n")),Object(o.b)("p",null,"Disappointing right? It's expecting ",Object(o.b)("inlineCode",{parentName:"p"},"Iterable&lt;[string, string]&gt;")," and an ",Object(o.b)("inlineCode",{parentName:"p"},"Array")," with 2 elements that are strings is ",Object(o.b)("em",{parentName:"p"},"not")," inferred to be that."),Object(o.b)("h2",{id:"this-does"},"This Does"),Object(o.b)("p",null,"It emerges that there is a way to do this though; you just need to give the compiler a clue. You need to include a type assertion of ",Object(o.b)("inlineCode",{parentName:"p"}," as [string, string]")," which tells the compiler that what you've just declared is a ",Object(o.b)("inlineCode",{parentName:"p"},"Tuple")," of ",Object(o.b)("inlineCode",{parentName:"p"},"string")," and ",Object(o.b)("inlineCode",{parentName:"p"},"string"),". (Please note that ",Object(o.b)("inlineCode",{parentName:"p"},"[string, string]")," corresponds to the types of the ",Object(o.b)("inlineCode",{parentName:"p"},"Key")," and ",Object(o.b)("inlineCode",{parentName:"p"},"Value")," of your ",Object(o.b)("inlineCode",{parentName:"p"},"Map")," and should be set accordingly.)"),Object(o.b)("p",null,"So a working version of the code looks like this:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-ts"},'const iAmAnArray [\n  { value: "value1", text: "hello" }\n  { value: "value2", text: "map" }\n];\n\nconst iAmAMap = new Map<string, string>(\n  iAmAnArray.map(x => [x.value, x.text] as [string, string])\n);\n')),Object(o.b)("p",null,"Or, to be terser, this:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-ts"},'const iAmAnArray [\n  { value: "value1", text: "hello" }\n  { value: "value2", text: "map" }\n];\n\nconst iAmAMap = new Map( // Look Ma!  No type annotations\n  iAmAnArray.map(x => [x.value, x.text] as [string, string])\n);\n')),Object(o.b)("p",null,"I've raised this as an issue with the TypeScript team; you can find details ",Object(o.b)("a",{parentName:"p",href:"https://github.com/Microsoft/TypeScript/issues/8936"},"here"),"."))}c.isMDXComponent=!0},965:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return y}));var r=n(0),a=n.n(r);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=a.a.createContext({}),c=function(e){var t=a.a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=c(e.components);return a.a.createElement(p.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},m=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),m=r,y=u["".concat(i,".").concat(m)]||u[m]||b[m]||o;return n?a.a.createElement(y,l(l({ref:t},p),{},{components:n})):a.a.createElement(y,l({ref:t},p))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);